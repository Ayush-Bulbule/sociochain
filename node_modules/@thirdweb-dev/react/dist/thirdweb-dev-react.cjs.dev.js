'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var wallets = require('@thirdweb-dev/wallets');
var basic = require('./basic-712c9bea.cjs.dev.js');
var coinbaseWallet = require('./headlessConnectUI-b057299e.cjs.dev.js');
var reactIcons = require('@radix-ui/react-icons');
var reactCore = require('@thirdweb-dev/react-core');
var React = require('react');
var styled = require('@emotion/styled');
var jsxRuntime = require('react/jsx-runtime');
var useWalletConnect = require('./useWalletConnect-f8926cc7.cjs.dev.js');
var paperWallet = require('./paperWallet-e81953d5.cjs.dev.js');
var safeWallet = require('./safeWallet-57c9c3a2.cjs.dev.js');
var walletConnect = require('./walletConnect-be8a5d41.cjs.dev.js');
var magicLink = require('./magicLink-89d37d1a.cjs.dev.js');
var useSafe = require('./useSafe-0a6a2809.cjs.dev.js');
var useMagic = require('./useMagic-94607c37.cjs.dev.js');
require('@emotion/react');
require('@radix-ui/react-dialog');
require('@radix-ui/colors');
require('detect-browser');
require('react-qr-code');
require('@tanstack/react-query');
require('@radix-ui/react-popover');
require('copy-to-clipboard');
require('@radix-ui/react-tooltip');
require('ethers');
require('@radix-ui/react-tabs');
require('fuse.js');
require('@radix-ui/react-dropdown-menu');
require('@thirdweb-dev/chains');
require('tiny-invariant');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var styled__default = /*#__PURE__*/_interopDefault(styled);

function useLocalWalletInfo(localConfiguredWallet) {
  const [walletData, setWalletData] = React.useState("loading");
  const createWalletInstance = reactCore.useCreateWalletInstance();
  const [localWallet, setLocalWallet] = React.useState(null);
  React.useEffect(() => {
    const wallet = createWalletInstance(localConfiguredWallet);
    setLocalWallet(wallet);
    if (localConfiguredWallet.config.persist) {
      wallet.getSavedData().then(data => {
        setWalletData(data);
      });
    }
  }, [createWalletInstance, localConfiguredWallet]);
  return {
    setLocalWallet,
    localWallet,
    walletData,
    meta: localConfiguredWallet.meta,
    persist: localConfiguredWallet.config.persist
  };
}

const DragNDrop = props => {
  const [error, setError] = React.useState(false);
  const [uploaded, setUploaded] = React.useState();
  const [isDragging, setIsDragging] = React.useState(false);
  const dragIn = e => {
    setError(false);
    setUploaded(undefined);
    setIsDragging(true);
    e.preventDefault();
    e.stopPropagation();
  };
  const dragOut = e => {
    setIsDragging(false);
    e.preventDefault();
    e.stopPropagation();
  };
  const handleFileUpload = file => {
    if (file.type !== props.accept) {
      setError(true);
    } else {
      setUploaded(file);
      props.onUpload(file);
    }
  };
  const drop = e => {
    setIsDragging(false);
    e.preventDefault();
    e.stopPropagation();
    if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
      handleFileUpload(e.dataTransfer.files[0]);
      e.dataTransfer.clearData();
    }
  };
  const message = coinbaseWallet.isMobile() ? "Click to Upload" : "Drop your file here or click to upload";
  return /*#__PURE__*/jsxRuntime.jsx("div", {
    onDragEnter: dragIn,
    onDragLeave: dragOut,
    onDragOver: e => {
      setIsDragging(true);
      e.preventDefault();
      e.stopPropagation();
    },
    onClick: () => {
      setError(false);
    },
    onDrop: drop,
    style: {
      cursor: "pointer"
    },
    children: /*#__PURE__*/jsxRuntime.jsxs("label", {
      htmlFor: "file-upload",
      children: [/*#__PURE__*/jsxRuntime.jsx("input", {
        id: "file-upload",
        type: "file",
        accept: props.accept,
        multiple: false,
        style: {
          display: "none"
        },
        onChange: e => {
          if (e.target.files && e.target.files.length > 0) {
            handleFileUpload(e.target.files[0]);
          }
        }
      }), /*#__PURE__*/jsxRuntime.jsx(DropContainer, {
        "data-error": error,
        "data-is-dragging": isDragging,
        children: !uploaded ? /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
          children: [" ", /*#__PURE__*/jsxRuntime.jsx(UploadIconSecondary, {
            width: basic.iconSize.xl,
            height: basic.iconSize.xl
          }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
            y: "md"
          }), /*#__PURE__*/jsxRuntime.jsx(Message, {
            children: message
          }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
            y: "md"
          }), error ? /*#__PURE__*/jsxRuntime.jsxs(ErrorMessage, {
            children: [" ", "Please upload a ", props.extension, " file", " "]
          }) : /*#__PURE__*/jsxRuntime.jsxs(ExtensionText, {
            children: [" ", props.extension, " "]
          })]
        }) : /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
          children: [/*#__PURE__*/jsxRuntime.jsxs(Message, {
            children: [uploaded.name, " uploaded successfully"]
          }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
            y: "md"
          }), /*#__PURE__*/jsxRuntime.jsx(CheckCircleIcon, {
            size: basic.iconSize.xl
          })]
        })
      })]
    })
  });
};
const UploadIconSecondary = styled__default["default"](reactIcons.UploadIcon)`
  color: ${props => props.theme.text.secondary};
  transition: transform 200ms ease, color 200ms ease;
`;
const DropContainer = styled__default["default"].div`
  border: 2px solid ${p => p.theme.bg.elevated};
  border-radius: ${basic.radius.md};
  padding: ${basic.spacing.xl} ${basic.spacing.md};
  display: flex;
  align-items: center;
  flex-direction: column;
  cursor: pointer;
  transition: border-color 200ms ease;

  &:hover,
  &[data-is-dragging="true"] {
    border-color: ${p => p.theme.link.primary};
    svg {
      color: ${p => p.theme.link.primary};
    }
  }

  &[data-error="true"] {
    border-color: ${p => p.theme.input.errorRing};
  }
`;
const ErrorMessage = styled__default["default"].p`
  color: ${p => p.theme.input.errorRing};
  font-size: ${basic.fontSize.sm};
  margin: 0;
`;
const ExtensionText = styled__default["default"].span`
  color: ${p => p.theme.text.secondary};
  font-size: ${basic.fontSize.sm};
`;
const CheckCircleIcon = props => /*#__PURE__*/jsxRuntime.jsxs("svg", {
  width: props.size,
  height: props.size,
  viewBox: "0 0 38 38",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  children: [/*#__PURE__*/jsxRuntime.jsx("path", {
    d: "M35.6666 17.4671V19.0004C35.6645 22.5945 34.5008 26.0916 32.3488 28.9701C30.1969 31.8487 27.1721 33.9546 23.7255 34.9736C20.279 35.9926 16.5954 35.8703 13.224 34.6247C9.85272 33.3792 6.97434 31.0773 5.01819 28.0622C3.06203 25.0472 2.1329 21.4805 2.36938 17.8943C2.60586 14.308 3.99526 10.8943 6.33039 8.16221C8.66551 5.43012 11.8212 3.52606 15.3269 2.734C18.8326 1.94194 22.5004 2.30432 25.7833 3.76709",
    stroke: "#5BD58C",
    strokeWidth: "3.33333",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /*#__PURE__*/jsxRuntime.jsx("path", {
    d: "M35.6667 5.66699L19 22.3503L14 17.3503",
    stroke: "#5BD58C",
    strokeWidth: "3.33333",
    strokeLinecap: "round",
    strokeLinejoin: "round"
  })]
});
const Message = styled__default["default"].p`
  color: ${p => p.theme.text.neutral};
  font-size: ${basic.fontSize.md};
  margin: 0;
  font-weight: 600;
`;

const LocalWalletModalHeader = props => {
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(basic.BackButton, {
      onClick: props.onBack
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "md"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Img, {
      src: props.meta.iconURL,
      width: basic.iconSize.xl,
      height: basic.iconSize.xl
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "sm"
    })]
  });
};

const ImportLocalWallet = props => {
  const [jsonString, setJsonString] = React.useState();
  const {
    setLocalWallet,
    meta
  } = useLocalWalletInfo(props.localWallet);
  const createWalletInstance = reactCore.useCreateWalletInstance();
  const [password, setPassword] = React.useState("");
  const [isWrongPassword, setIsWrongPassword] = React.useState(false);
  const [showPassword, setShowPassword] = React.useState(false);
  const [importedAddress, setImportedAddress] = React.useState();
  const thirdwebWalletContext = reactCore.useThirdwebWallet();
  const handleImport = async () => {
    const localWallet = createWalletInstance(props.localWallet);
    if (!localWallet || !jsonString) {
      throw new Error("Invalid state");
    }
    try {
      await localWallet.import({
        encryptedJson: jsonString,
        password
      });
    } catch (e) {
      console.error(e);
      setIsWrongPassword(true);
      return;
    }
    await localWallet.save({
      strategy: "encryptedJson",
      password
    });
    thirdwebWalletContext.handleWalletConnect(localWallet);
    setLocalWallet(localWallet);
    props.onConnect();
  };
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(LocalWalletModalHeader, {
      onBack: props.goBack,
      meta: meta
    }), /*#__PURE__*/jsxRuntime.jsx(basic.ModalTitle, {
      style: {
        textAlign: "left"
      },
      children: "Import Wallet"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "md"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.ModalDescription, {
      children: "The application can authorize any transactions on behalf of the wallet without any approvals. We recommend only connecting to trusted applications."
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsx(DragNDrop, {
      extension: "JSON",
      accept: "application/json",
      onUpload: file => {
        const reader = new FileReader();
        reader.onload = event => {
          setJsonString(event.target?.result);
          const obj = JSON.parse(event.target?.result);
          setImportedAddress(obj.address);
        };
        reader.readAsText(file, "utf-8");
      }
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsxs("form", {
      onSubmit: e => {
        e.preventDefault();
        handleImport();
      },
      children: [jsonString && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
        children: [/*#__PURE__*/jsxRuntime.jsx("input", {
          type: "text",
          name: "username",
          autoComplete: "off",
          value: importedAddress || "",
          disabled: true,
          style: {
            display: "none"
          }
        }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.FormFieldWithIconButton, {
          required: true,
          noSave: true,
          name: "password",
          autocomplete: "off",
          id: "password",
          onChange: value => {
            setPassword(value);
            setIsWrongPassword(false);
          },
          right: {
            onClick: () => setShowPassword(!showPassword),
            icon: showPassword ? /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeClosedIcon, {}) : /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeOpenIcon, {})
          },
          label: "Password",
          type: showPassword ? "text" : "password",
          value: password,
          error: isWrongPassword ? "Wrong Password" : ""
        }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
          y: "xl"
        })]
      }), /*#__PURE__*/jsxRuntime.jsx(basic.FormFooter, {
        children: /*#__PURE__*/jsxRuntime.jsx(basic.Button, {
          variant: "inverted",
          type: "submit",
          disabled: !jsonString,
          style: {
            minWidth: "110px",
            opacity: jsonString ? 1 : 0.5
          },
          children: "Import"
        })
      })]
    })]
  });
};

const TextDivider = styled__default["default"].div`
  display: flex;
  align-items: center;
  color: ${p => p.theme.text.secondary};
  font-size: ${basic.fontSize.sm};
  &::before,
  &::after {
    content: "";
    flex: 1;
    border-bottom: 1px solid ${p => p.theme.bg.highlighted};
  }

  span {
    margin: 0 1rem;
  }
`;

const CreateLocalWallet_Password = props => {
  const [password, setPassword] = React.useState("");
  const [confirmPassword, setConfirmPassword] = React.useState("");
  const [showPassword, setShowPassword] = React.useState(false);
  const passwordMismatch = confirmPassword && password !== confirmPassword;
  const [isConnecting, setIsConnecting] = React.useState(false);
  const {
    localWallet,
    meta
  } = useLocalWalletInfo(props.localWallet);
  const thirdwebWalletContext = reactCore.useThirdwebWallet();
  const [showImportScreen, setShowImportScreen] = React.useState(false);
  const [generatedAddress, setGeneratedAddress] = React.useState(null);

  // generating wallet before it's required to render a form with hidden address as username for better autofill
  React.useEffect(() => {
    if (!localWallet || showImportScreen || localWallet.ethersWallet) {
      return;
    }
    localWallet.generate().then(_address => {
      setGeneratedAddress(_address);
    });
  }, [localWallet, showImportScreen]);
  if (showImportScreen) {
    return /*#__PURE__*/jsxRuntime.jsx(ImportLocalWallet, {
      localWallet: props.localWallet,
      onConnect: props.onConnect,
      goBack: () => {
        setShowImportScreen(false);
      }
    });
  }
  const handleConnect = async () => {
    if (passwordMismatch || !localWallet) {
      throw new Error("Invalid state");
    }
    setIsConnecting(true);
    localWallet.connect();
    await localWallet.save({
      strategy: "encryptedJson",
      password
    });
    thirdwebWalletContext.handleWalletConnect(localWallet);
    setIsConnecting(false);
    props.onConnect();
  };
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(LocalWalletModalHeader, {
      onBack: props.goBack,
      meta: meta
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Flex, {
      alignItems: "center",
      gap: "xs",
      children: /*#__PURE__*/jsxRuntime.jsx(basic.ModalTitle, {
        children: "Guest Wallet"
      })
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "sm"
    }), /*#__PURE__*/jsxRuntime.jsxs(basic.ModalDescription, {
      children: ["Choose a password for your wallet, you", `'`, "ll be able to access and export this wallet with the same password."]
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsxs("form", {
      onSubmit: e => {
        e.preventDefault();
        handleConnect();
      },
      children: [/*#__PURE__*/jsxRuntime.jsx("input", {
        type: "text",
        name: "username",
        autoComplete: "off",
        value: generatedAddress || "",
        disabled: true,
        style: {
          display: "none"
        }
      }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.FormFieldWithIconButton, {
        name: "password",
        required: true,
        autocomplete: "new-password",
        id: "new-password",
        onChange: value => setPassword(value),
        right: {
          icon: showPassword ? /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeClosedIcon, {}) : /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeOpenIcon, {}),
          onClick: () => setShowPassword(!showPassword)
        },
        label: "Password",
        type: showPassword ? "text" : "password",
        value: password
      }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.FormFieldWithIconButton, {
        name: "confirm-password",
        required: true,
        autocomplete: "new-password",
        id: "confirm-password",
        onChange: value => setConfirmPassword(value),
        right: {
          icon: showPassword ? /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeClosedIcon, {}) : /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeOpenIcon, {}),
          onClick: () => setShowPassword(!showPassword)
        },
        label: "Confirm Password",
        type: showPassword ? "text" : "password",
        value: confirmPassword,
        error: passwordMismatch ? "Passwords don't match" : ""
      }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxRuntime.jsxs(basic.Button, {
        variant: "inverted",
        type: "submit",
        style: {
          width: "100%",
          gap: basic.spacing.sm
        },
        children: [isConnecting ? "Connecting" : "Create new wallet", isConnecting && /*#__PURE__*/jsxRuntime.jsx(basic.Spinner, {
          size: "sm",
          color: "inverted"
        })]
      })]
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "xxl"
    }), /*#__PURE__*/jsxRuntime.jsx(TextDivider, {
      children: /*#__PURE__*/jsxRuntime.jsx("span", {
        children: "OR"
      })
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Flex, {
      justifyContent: "center",
      children: /*#__PURE__*/jsxRuntime.jsx(basic.Button, {
        variant: "link",
        onClick: () => {
          setShowImportScreen(true);
        },
        children: "Import wallet"
      })
    })]
  });
};
const CreateLocalWallet_Guest = props => {
  const {
    localWallet
  } = useLocalWalletInfo(props.localWallet);
  const thirdwebWalletContext = reactCore.useThirdwebWallet();
  const handleConnect = React.useCallback(async () => {
    if (!localWallet) {
      throw new Error("Invalid state");
    }
    await localWallet.generate();
    await localWallet.connect();
    thirdwebWalletContext.handleWalletConnect(localWallet);
    props.onConnect();
  }, [localWallet, thirdwebWalletContext, props]);
  const connecting = React.useRef(false);
  React.useEffect(() => {
    if (connecting.current || !localWallet) {
      return;
    }
    connecting.current = true;
    handleConnect();
  }, [handleConnect, localWallet]);
  return /*#__PURE__*/jsxRuntime.jsx(basic.Flex, {
    justifyContent: "center",
    alignItems: "center",
    style: {
      height: "300px"
    },
    children: /*#__PURE__*/jsxRuntime.jsx(basic.Spinner, {
      size: "lg",
      color: "link"
    })
  });
};

const OverrideConfirmation = props => {
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(LocalWalletModalHeader, {
      onBack: props.onBack,
      meta: props.meta
    }), /*#__PURE__*/jsxRuntime.jsx(basic.ModalTitle, {
      children: "Backup your wallet"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "md"
    }), /*#__PURE__*/jsxRuntime.jsxs("div", {
      style: {
        lineHeight: 1.5
      },
      children: [/*#__PURE__*/jsxRuntime.jsx(useWalletConnect.SecondaryText, {
        children: "Your current wallet will be deleted if you create a new wallet. Backup wallet to your device before creating a new wallet"
      }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxRuntime.jsxs(basic.FormFooter, {
        children: [/*#__PURE__*/jsxRuntime.jsx(basic.Button, {
          variant: "inverted",
          onClick: props.onBackup,
          children: "Backup wallet"
        }), /*#__PURE__*/jsxRuntime.jsx(basic.Button, {
          variant: "danger",
          onClick: props.onSkip,
          children: "Skip"
        })]
      })]
    })]
  });
};

/**
 * For No-Credential scenario
 */
const ReconnectLocalWallet = props => {
  const [password, setPassword] = React.useState("");
  const [showPassword, setShowPassword] = React.useState(false);
  const [isWrongPassword, setIsWrongPassword] = React.useState(false);
  const thirdwebWalletContext = reactCore.useThirdwebWallet();
  const [isConnecting, setIsConnecting] = React.useState(false);
  const [showCreate, setShowCreate] = React.useState(false);
  const [showBackupConfirmation, setShowBackupConfirmation] = React.useState(false);
  const [showExport, setShowExport] = React.useState(false);
  const {
    localWallet,
    meta,
    walletData
  } = useLocalWalletInfo(props.localWallet);
  const savedAddress = walletData ? walletData === "loading" ? "" : walletData.address : "";
  if (showExport) {
    if (!localWallet) {
      throw new Error("Invalid state");
    }
    return /*#__PURE__*/jsxRuntime.jsx(useWalletConnect.ExportLocalWallet, {
      localWallet: localWallet,
      onBack: () => {
        setShowExport(false);
      },
      onExport: () => {
        setShowExport(false);
        setShowBackupConfirmation(false);
        setShowCreate(true);
      }
    });
  }
  if (showBackupConfirmation) {
    return /*#__PURE__*/jsxRuntime.jsx(OverrideConfirmation, {
      meta: meta,
      onBackup: () => {
        setShowExport(true);
      },
      onSkip: () => {
        setShowBackupConfirmation(false);
        setShowCreate(true);
      },
      onBack: () => {
        setShowBackupConfirmation(false);
      }
    });
  }
  if (showCreate) {
    return /*#__PURE__*/jsxRuntime.jsx(CreateLocalWallet_Password, {
      localWallet: props.localWallet,
      goBack: () => {
        setShowCreate(false);
      },
      onConnect: props.onConnect
    });
  }
  const handleReconnect = async () => {
    if (!localWallet) {
      throw new Error("Invalid state");
    }
    setIsConnecting(true);
    try {
      await localWallet.load({
        strategy: "encryptedJson",
        password
      });
      await localWallet.connect();
      thirdwebWalletContext.handleWalletConnect(localWallet);
      props.onConnect();
    } catch (e) {
      setIsWrongPassword(true);
    }
    setIsConnecting(false);
  };
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(LocalWalletModalHeader, {
      onBack: props.goBack,
      meta: meta
    }), /*#__PURE__*/jsxRuntime.jsx(basic.ModalTitle, {
      style: {
        textAlign: "left"
      },
      children: "Guest Wallet"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "xs"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.ModalDescription, {
      children: "Connect to saved wallet on your device"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Label, {
      children: "Saved Wallet"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "sm"
    }), /*#__PURE__*/jsxRuntime.jsx(useWalletConnect.SecondaryText, {
      children: savedAddress === "" ? "Loading..." : useWalletConnect.shortenAddress(savedAddress)
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsxs("form", {
      onSubmit: e => {
        e.preventDefault();
        handleReconnect();
      },
      children: [/*#__PURE__*/jsxRuntime.jsx("input", {
        type: "text",
        name: "username",
        autoComplete: "off",
        value: savedAddress,
        disabled: true,
        style: {
          display: "none"
        }
      }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.FormFieldWithIconButton, {
        required: true,
        name: "current-password",
        autocomplete: "current-password",
        id: "current-password",
        onChange: value => {
          setPassword(value);
          setIsWrongPassword(false);
        },
        right: {
          onClick: () => setShowPassword(!showPassword),
          icon: showPassword ? /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeClosedIcon, {}) : /*#__PURE__*/jsxRuntime.jsx(reactIcons.EyeOpenIcon, {})
        },
        label: "Password",
        type: showPassword ? "text" : "password",
        value: password,
        error: isWrongPassword ? "Wrong Password" : ""
      }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
        y: "lg"
      }), /*#__PURE__*/jsxRuntime.jsx(basic.FormFooter, {
        children: /*#__PURE__*/jsxRuntime.jsxs(basic.Button, {
          variant: "inverted",
          type: "submit",
          style: {
            display: "flex",
            gap: basic.spacing.sm
          },
          children: ["Connect", isConnecting && /*#__PURE__*/jsxRuntime.jsx(basic.Spinner, {
            size: "sm",
            color: "inverted"
          })]
        })
      })]
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "xxl"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Button, {
      variant: "link",
      style: {
        textAlign: "center",
        width: "100%",
        padding: "2px"
      },
      onClick: () => {
        setShowBackupConfirmation(true);
      },
      children: "Create a new wallet"
    })]
  });
};

const LocalWalletConnectUI = props => {
  const {
    walletData
  } = useLocalWalletInfo(props.localWallet);
  if (!props.localWallet.config.persist) {
    return /*#__PURE__*/jsxRuntime.jsx(CreateLocalWallet_Guest, {
      localWallet: props.localWallet,
      goBack: props.goBack,
      onConnect: props.close
    });
  }
  if (walletData === "loading") {
    return /*#__PURE__*/jsxRuntime.jsx(basic.Flex, {
      justifyContent: "center",
      alignItems: "center",
      style: {
        height: "300px"
      },
      children: /*#__PURE__*/jsxRuntime.jsx(basic.Spinner, {
        size: "lg",
        color: "primary"
      })
    });
  }
  if (walletData) {
    return /*#__PURE__*/jsxRuntime.jsx(ReconnectLocalWallet, {
      onConnect: props.close,
      goBack: props.goBack,
      localWallet: props.localWallet
    });
  }
  return /*#__PURE__*/jsxRuntime.jsx(CreateLocalWallet_Password, {
    goBack: props.goBack,
    localWallet: props.localWallet,
    onConnect: props.close
  });
};

const localWallet = config => {
  const configuredWallet = {
    id: wallets.LocalWallet.id,
    meta: {
      ...wallets.LocalWallet.meta,
      name: "Guest Wallet"
    },
    create: options => new wallets.LocalWallet(options),
    config: {
      persist: config && config.persist !== undefined ? config.persist : true
    },
    connectUI(props) {
      return /*#__PURE__*/jsxRuntime.jsx(LocalWalletConnectUI, {
        ...props,
        localWallet: configuredWallet
      });
    },
    isInstalled() {
      // TODO
      return false;
    }
  };
  return configuredWallet;
};

const SmartWalletConnecting = props => {
  const activeWallet = reactCore.useWallet(); // personal wallet

  const connect = reactCore.useConnect();
  const connectedChain = reactCore.useActiveChain();
  const targetChain = reactCore.useThirdwebWallet().activeChain;
  const mismatch = reactCore.useNetworkMismatch();
  const [connectError, setConnectError] = React.useState(false);
  const [switchError, setSwitchError] = React.useState(false);
  const [switchingNetwork, setSwitchingNetwork] = React.useState(false);
  const connectionStatus = reactCore.useConnectionStatus();
  const requiresConfirmation = !coinbaseWallet.useIsHeadlessWallet();
  const {
    onConnect
  } = props;
  const handleConnect = React.useCallback(async () => {
    if (!activeWallet || !connectedChain) {
      return;
    }
    setConnectError(false);
    try {
      await connect(props.smartWallet, {
        personalWallet: activeWallet
      });
      onConnect();
    } catch (e) {
      console.error(e);
      setConnectError(true);
    }
  }, [activeWallet, connectedChain, connect, props.smartWallet, onConnect]);
  React.useEffect(() => {
    if (!mismatch) {
      handleConnect();
    }
  }, [mismatch, handleConnect, activeWallet, connectedChain]);
  if (connectionStatus === "connecting" || !mismatch) {
    return /*#__PURE__*/jsxRuntime.jsx(basic.Flex, {
      style: {
        height: "300px",
        justifyContent: "center",
        alignItems: "center"
      },
      children: /*#__PURE__*/jsxRuntime.jsx(basic.Spinner, {
        color: "link",
        size: "lg"
      })
    });
  }
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(basic.BackButton, {
      onClick: props.onBack
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "md"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Img, {
      src: props.smartWallet.meta.iconURL,
      width: basic.iconSize.xl,
      height: basic.iconSize.xl
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.ModalTitle, {
      children: "Network Mismatch"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "md"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.ModalDescription, {
      children: "Selected wallet is not connected to the required network"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), connectError && /*#__PURE__*/jsxRuntime.jsxs(basic.ErrorMessage, {
      style: {
        display: "flex",
        gap: basic.spacing.sm,
        alignItems: "center",
        fontSize: basic.fontSize.sm
      },
      children: [/*#__PURE__*/jsxRuntime.jsx(reactIcons.ExclamationTriangleIcon, {
        width: basic.iconSize.sm,
        height: basic.iconSize.sm
      }), /*#__PURE__*/jsxRuntime.jsxs("span", {
        children: ["Could not connect to Smart Wallet. ", /*#__PURE__*/jsxRuntime.jsx("br", {})]
      })]
    }), /*#__PURE__*/jsxRuntime.jsxs(basic.Button, {
      type: "button",
      variant: "secondary",
      style: {
        display: "flex",
        alignItems: "center",
        gap: basic.spacing.sm
      },
      onClick: async () => {
        if (!activeWallet) {
          throw new Error("No active wallet");
        }
        setConnectError(false);
        setSwitchError(false);
        setSwitchingNetwork(true);
        try {
          await activeWallet.switchChain(targetChain.chainId);
        } catch (e) {
          setSwitchError(true);
        } finally {
          setSwitchingNetwork(false);
        }
      },
      children: [" ", switchingNetwork ? "Switching" : "Switch Network", switchingNetwork && /*#__PURE__*/jsxRuntime.jsx(basic.Spinner, {
        size: "sm",
        color: "primary"
      })]
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "md"
    }), switchingNetwork && requiresConfirmation && /*#__PURE__*/jsxRuntime.jsx(ConfirmMessage, {
      children: " Confirm in your wallet "
    }), switchError && /*#__PURE__*/jsxRuntime.jsxs(basic.ErrorMessage, {
      style: {
        display: "flex",
        gap: basic.spacing.sm,
        alignItems: "center",
        fontSize: basic.fontSize.sm
      },
      children: [/*#__PURE__*/jsxRuntime.jsx(reactIcons.ExclamationTriangleIcon, {
        width: basic.iconSize.sm,
        height: basic.iconSize.sm
      }), /*#__PURE__*/jsxRuntime.jsx("span", {
        children: "Failed to switch network."
      })]
    })]
  });
};
const ConfirmMessage = styled__default["default"].p`
  font-size: ${basic.fontSize.sm};
  margin: 0;
  color: ${p => p.theme.link.primary};
`;

const SelectPersonalWallet = props => {
  const guestWallet = props.personalWallets.find(w => w.id === wallets.walletIds.localWallet);
  const personalWallets = props.personalWallets.filter(w => w.id !== wallets.walletIds.localWallet);
  return /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
    children: [/*#__PURE__*/jsxRuntime.jsx(basic.BackButton, {
      onClick: props.onBack
    }), /*#__PURE__*/jsxRuntime.jsx(IconContainer, {
      children: /*#__PURE__*/jsxRuntime.jsx(basic.Img, {
        src: props.smartWallet.meta.iconURL,
        width: basic.iconSize.xl,
        height: basic.iconSize.xl
      })
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.ModalTitle, {
      children: "Link Personal Wallet"
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "sm"
    }), /*#__PURE__*/jsxRuntime.jsxs(basic.ModalDescription, {
      children: ["Select a personal wallet to access your account.", " ", /*#__PURE__*/jsxRuntime.jsxs(basic.HelperLink, {
        md: true,
        href: "https://portal.thirdweb.com/wallet/smart-wallet",
        target: "_blank",
        style: {
          display: "inline",
          whiteSpace: "nowrap"
        },
        children: [" ", "Learn More", " "]
      })]
    }), /*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
      y: "lg"
    }), /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.WalletSelection, {
      configuredWallets: personalWallets,
      selectWallet: props.selectWallet
    }), guestWallet && /*#__PURE__*/jsxRuntime.jsxs(jsxRuntime.Fragment, {
      children: [/*#__PURE__*/jsxRuntime.jsx(basic.Spacer, {
        y: "xl"
      }), /*#__PURE__*/jsxRuntime.jsx(basic.Flex, {
        justifyContent: "center",
        children: /*#__PURE__*/jsxRuntime.jsx(basic.Button, {
          variant: "link",
          onClick: () => {
            props.selectWallet(guestWallet);
          },
          children: "Continue as guest"
        })
      })]
    })]
  });
};
const IconContainer = styled__default["default"].div`
  margin-top: ${basic.spacing.lg};
`;

const smartWallet = config => {
  const configuredWallet = {
    id: wallets.SmartWallet.id,
    meta: wallets.SmartWallet.meta,
    create: options => new wallets.SmartWallet({
      ...options,
      ...config
    }),
    connectUI(props) {
      return /*#__PURE__*/jsxRuntime.jsx(SmartConnectUI, {
        ...props,
        configuredWallet: configuredWallet
      });
    },
    isInstalled() {
      return false;
    },
    config: {
      ...config,
      personalWallets: config?.personalWallets || coinbaseWallet.defaultWallets
    }
  };
  return configuredWallet;
};
const SmartConnectUI = props => {
  const activeWallet = reactCore.useWallet();
  const {
    configuredWallet
  } = props;
  const [personalConfiguredWallet, setPersonalConfiguredWallet] = React.useState();
  if (personalConfiguredWallet) {
    const _props = {
      close: () => {
        setPersonalConfiguredWallet(undefined);
        props.close(false); // do not reset UI
      },

      goBack: () => {
        setPersonalConfiguredWallet(undefined);
      },
      isOpen: props.isOpen,
      open: props.open
    };
    if (personalConfiguredWallet.connectUI) {
      return /*#__PURE__*/jsxRuntime.jsx(personalConfiguredWallet.connectUI, {
        ..._props
      });
    }
    return /*#__PURE__*/jsxRuntime.jsx(coinbaseWallet.HeadlessConnectUI, {
      ..._props,
      configuredWallet: personalConfiguredWallet
    });
  }
  if (!activeWallet) {
    return /*#__PURE__*/jsxRuntime.jsx(SelectPersonalWallet, {
      personalWallets: configuredWallet.config.personalWallets,
      onBack: props.goBack,
      smartWallet: configuredWallet,
      selectWallet: setPersonalConfiguredWallet
    });
  }
  return /*#__PURE__*/jsxRuntime.jsx(SmartWalletConnecting, {
    onBack: props.goBack,
    onConnect: props.close,
    smartWallet: configuredWallet
  });
};

exports.coinbaseWallet = coinbaseWallet.coinbaseWallet;
exports.metamaskWallet = coinbaseWallet.metamaskWallet;
exports.walletConnectV1 = coinbaseWallet.walletConnectV1;
exports.ConnectWallet = useWalletConnect.ConnectWallet;
exports.MediaRenderer = useWalletConnect.MediaRenderer;
exports.NetworkSelector = useWalletConnect.NetworkSelector;
exports.ThirdwebNftMedia = useWalletConnect.ThirdwebNftMedia;
exports.ThirdwebProvider = useWalletConnect.ThirdwebProvider;
exports.Web3Button = useWalletConnect.Web3Button;
exports.useCoinbaseWallet = useWalletConnect.useCoinbaseWallet;
exports.useInstalledWallets = useWalletConnect.useInstalledWallets;
exports.useMetamask = useWalletConnect.useMetamask;
exports.usePaperWallet = useWalletConnect.usePaperWallet;
exports.usePaperWalletUserEmail = useWalletConnect.usePaperWalletUserEmail;
exports.useResolvedMediaType = useWalletConnect.useResolvedMediaType;
exports.useWalletConnect = useWalletConnect.useWalletConnect;
exports.useWalletConnectV1 = useWalletConnect.useWalletConnectV1;
exports.paperWallet = paperWallet.paperWallet;
exports.safeWallet = safeWallet.safeWallet;
exports.walletConnect = walletConnect.walletConnect;
exports.magicLink = magicLink.magicLink;
exports.useSafe = useSafe.useSafe;
exports.useMagic = useMagic.useMagic;
exports.localWallet = localWallet;
exports.smartWallet = smartWallet;
Object.keys(reactCore).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () { return reactCore[k]; }
  });
});
